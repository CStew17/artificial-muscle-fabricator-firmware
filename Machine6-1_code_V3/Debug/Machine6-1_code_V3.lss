
Machine6-1_code_V3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  00000774  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000700  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000007  00800200  00800200  00000774  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000774  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000007a4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c8  00000000  00000000  000007e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001a69  00000000  00000000  000008ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e2d  00000000  00000000  00002315  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c2f  00000000  00000000  00003142  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000210  00000000  00000000  00003d74  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006fc  00000000  00000000  00003f84  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000f5e  00000000  00000000  00004680  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d0  00000000  00000000  000055de  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	81 c0       	rjmp	.+258    	; 0x108 <__bad_interrupt>
   6:	00 00       	nop
   8:	f5 c0       	rjmp	.+490    	; 0x1f4 <__vector_2>
   a:	00 00       	nop
   c:	c8 c0       	rjmp	.+400    	; 0x19e <__vector_3>
   e:	00 00       	nop
  10:	da c0       	rjmp	.+436    	; 0x1c6 <__vector_4>
  12:	00 00       	nop
  14:	79 c0       	rjmp	.+242    	; 0x108 <__bad_interrupt>
  16:	00 00       	nop
  18:	77 c0       	rjmp	.+238    	; 0x108 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	75 c0       	rjmp	.+234    	; 0x108 <__bad_interrupt>
  1e:	00 00       	nop
  20:	73 c0       	rjmp	.+230    	; 0x108 <__bad_interrupt>
  22:	00 00       	nop
  24:	71 c0       	rjmp	.+226    	; 0x108 <__bad_interrupt>
  26:	00 00       	nop
  28:	6f c0       	rjmp	.+222    	; 0x108 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	6d c0       	rjmp	.+218    	; 0x108 <__bad_interrupt>
  2e:	00 00       	nop
  30:	6b c0       	rjmp	.+214    	; 0x108 <__bad_interrupt>
  32:	00 00       	nop
  34:	69 c0       	rjmp	.+210    	; 0x108 <__bad_interrupt>
  36:	00 00       	nop
  38:	67 c0       	rjmp	.+206    	; 0x108 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	65 c0       	rjmp	.+202    	; 0x108 <__bad_interrupt>
  3e:	00 00       	nop
  40:	63 c0       	rjmp	.+198    	; 0x108 <__bad_interrupt>
  42:	00 00       	nop
  44:	61 c0       	rjmp	.+194    	; 0x108 <__bad_interrupt>
  46:	00 00       	nop
  48:	5f c0       	rjmp	.+190    	; 0x108 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	5d c0       	rjmp	.+186    	; 0x108 <__bad_interrupt>
  4e:	00 00       	nop
  50:	5b c0       	rjmp	.+182    	; 0x108 <__bad_interrupt>
  52:	00 00       	nop
  54:	59 c0       	rjmp	.+178    	; 0x108 <__bad_interrupt>
  56:	00 00       	nop
  58:	57 c0       	rjmp	.+174    	; 0x108 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	56 c0       	rjmp	.+172    	; 0x10a <__vector_23>
  5e:	00 00       	nop
  60:	53 c0       	rjmp	.+166    	; 0x108 <__bad_interrupt>
  62:	00 00       	nop
  64:	51 c0       	rjmp	.+162    	; 0x108 <__bad_interrupt>
  66:	00 00       	nop
  68:	4f c0       	rjmp	.+158    	; 0x108 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	4d c0       	rjmp	.+154    	; 0x108 <__bad_interrupt>
  6e:	00 00       	nop
  70:	4b c0       	rjmp	.+150    	; 0x108 <__bad_interrupt>
  72:	00 00       	nop
  74:	49 c0       	rjmp	.+146    	; 0x108 <__bad_interrupt>
  76:	00 00       	nop
  78:	47 c0       	rjmp	.+142    	; 0x108 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	45 c0       	rjmp	.+138    	; 0x108 <__bad_interrupt>
  7e:	00 00       	nop
  80:	43 c0       	rjmp	.+134    	; 0x108 <__bad_interrupt>
  82:	00 00       	nop
  84:	41 c0       	rjmp	.+130    	; 0x108 <__bad_interrupt>
  86:	00 00       	nop
  88:	3f c0       	rjmp	.+126    	; 0x108 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	3d c0       	rjmp	.+122    	; 0x108 <__bad_interrupt>
  8e:	00 00       	nop
  90:	3b c0       	rjmp	.+118    	; 0x108 <__bad_interrupt>
  92:	00 00       	nop
  94:	39 c0       	rjmp	.+114    	; 0x108 <__bad_interrupt>
  96:	00 00       	nop
  98:	37 c0       	rjmp	.+110    	; 0x108 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	35 c0       	rjmp	.+106    	; 0x108 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	33 c0       	rjmp	.+102    	; 0x108 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	31 c0       	rjmp	.+98     	; 0x108 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	2f c0       	rjmp	.+94     	; 0x108 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	2d c0       	rjmp	.+90     	; 0x108 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	2b c0       	rjmp	.+86     	; 0x108 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	29 c0       	rjmp	.+82     	; 0x108 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	27 c0       	rjmp	.+78     	; 0x108 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	25 c0       	rjmp	.+74     	; 0x108 <__bad_interrupt>
  be:	00 00       	nop
  c0:	23 c0       	rjmp	.+70     	; 0x108 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	21 c0       	rjmp	.+66     	; 0x108 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	1f c0       	rjmp	.+62     	; 0x108 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	1d c0       	rjmp	.+58     	; 0x108 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	1b c0       	rjmp	.+54     	; 0x108 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	19 c0       	rjmp	.+50     	; 0x108 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	17 c0       	rjmp	.+46     	; 0x108 <__bad_interrupt>
  da:	00 00       	nop
  dc:	15 c0       	rjmp	.+42     	; 0x108 <__bad_interrupt>
  de:	00 00       	nop
  e0:	13 c0       	rjmp	.+38     	; 0x108 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_clear_bss>:
  f4:	22 e0       	ldi	r18, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	01 c0       	rjmp	.+2      	; 0xfe <.do_clear_bss_start>

000000fc <.do_clear_bss_loop>:
  fc:	1d 92       	st	X+, r1

000000fe <.do_clear_bss_start>:
  fe:	a7 30       	cpi	r26, 0x07	; 7
 100:	b2 07       	cpc	r27, r18
 102:	e1 f7       	brne	.-8      	; 0xfc <.do_clear_bss_loop>
 104:	ea d2       	rcall	.+1492   	; 0x6da <main>
 106:	fa c2       	rjmp	.+1524   	; 0x6fc <_exit>

00000108 <__bad_interrupt>:
 108:	7b cf       	rjmp	.-266    	; 0x0 <__vectors>

0000010a <__vector_23>:
*/

//Converts time in milliseconds into character bitmaps which are written to the GDDRAM to be displayed on the OLED screen
void displayTime(unsigned long m)
{
	displayNum(m, 0);
 10a:	1f 92       	push	r1
 10c:	0f 92       	push	r0
 10e:	0f b6       	in	r0, 0x3f	; 63
 110:	0f 92       	push	r0
 112:	11 24       	eor	r1, r1
 114:	0f 93       	push	r16
 116:	1f 93       	push	r17
 118:	2f 93       	push	r18
 11a:	3f 93       	push	r19
 11c:	4f 93       	push	r20
 11e:	5f 93       	push	r21
 120:	6f 93       	push	r22
 122:	7f 93       	push	r23
 124:	8f 93       	push	r24
 126:	9f 93       	push	r25
 128:	00 91 03 02 	lds	r16, 0x0203	; 0x800203 <milliseconds>
 12c:	10 91 04 02 	lds	r17, 0x0204	; 0x800204 <milliseconds+0x1>
 130:	20 91 05 02 	lds	r18, 0x0205	; 0x800205 <milliseconds+0x2>
 134:	30 91 06 02 	lds	r19, 0x0206	; 0x800206 <milliseconds+0x3>
 138:	9f b7       	in	r25, 0x3f	; 63
 13a:	b9 01       	movw	r22, r18
 13c:	a8 01       	movw	r20, r16
 13e:	4f 5f       	subi	r20, 0xFF	; 255
 140:	5f 4f       	sbci	r21, 0xFF	; 255
 142:	6f 4f       	sbci	r22, 0xFF	; 255
 144:	7f 4f       	sbci	r23, 0xFF	; 255
 146:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <frac_ms>
 14a:	8d 5f       	subi	r24, 0xFD	; 253
 14c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <frac_ms>
 150:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <frac_ms>
 154:	8d 37       	cpi	r24, 0x7D	; 125
 156:	58 f0       	brcs	.+22     	; 0x16e <__vector_23+0x64>
 158:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <frac_ms>
 15c:	8d 57       	subi	r24, 0x7D	; 125
 15e:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <frac_ms>
 162:	b9 01       	movw	r22, r18
 164:	a8 01       	movw	r20, r16
 166:	4e 5f       	subi	r20, 0xFE	; 254
 168:	5f 4f       	sbci	r21, 0xFF	; 255
 16a:	6f 4f       	sbci	r22, 0xFF	; 255
 16c:	7f 4f       	sbci	r23, 0xFF	; 255
 16e:	40 93 03 02 	sts	0x0203, r20	; 0x800203 <milliseconds>
 172:	50 93 04 02 	sts	0x0204, r21	; 0x800204 <milliseconds+0x1>
 176:	60 93 05 02 	sts	0x0205, r22	; 0x800205 <milliseconds+0x2>
 17a:	70 93 06 02 	sts	0x0206, r23	; 0x800206 <milliseconds+0x3>
 17e:	9f bf       	out	0x3f, r25	; 63
 180:	9f 91       	pop	r25
 182:	8f 91       	pop	r24
 184:	7f 91       	pop	r23
 186:	6f 91       	pop	r22
 188:	5f 91       	pop	r21
 18a:	4f 91       	pop	r20
 18c:	3f 91       	pop	r19
 18e:	2f 91       	pop	r18
 190:	1f 91       	pop	r17
 192:	0f 91       	pop	r16
 194:	0f 90       	pop	r0
 196:	0f be       	out	0x3f, r0	; 63
 198:	0f 90       	pop	r0
 19a:	1f 90       	pop	r1
 19c:	18 95       	reti

0000019e <__vector_3>:
 19e:	1f 92       	push	r1
 1a0:	0f 92       	push	r0
 1a2:	0f b6       	in	r0, 0x3f	; 63
 1a4:	0f 92       	push	r0
 1a6:	11 24       	eor	r1, r1
 1a8:	8f 93       	push	r24
 1aa:	9f 93       	push	r25
 1ac:	81 e0       	ldi	r24, 0x01	; 1
 1ae:	90 e0       	ldi	r25, 0x00	; 0
 1b0:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 1b4:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
 1b8:	9f 91       	pop	r25
 1ba:	8f 91       	pop	r24
 1bc:	0f 90       	pop	r0
 1be:	0f be       	out	0x3f, r0	; 63
 1c0:	0f 90       	pop	r0
 1c2:	1f 90       	pop	r1
 1c4:	18 95       	reti

000001c6 <__vector_4>:
 1c6:	1f 92       	push	r1
 1c8:	0f 92       	push	r0
 1ca:	0f b6       	in	r0, 0x3f	; 63
 1cc:	0f 92       	push	r0
 1ce:	11 24       	eor	r1, r1
 1d0:	8f 93       	push	r24
 1d2:	9f 93       	push	r25
 1d4:	82 e0       	ldi	r24, 0x02	; 2
 1d6:	90 e0       	ldi	r25, 0x00	; 0
 1d8:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 1dc:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
 1e0:	85 b1       	in	r24, 0x05	; 5
 1e2:	81 60       	ori	r24, 0x01	; 1
 1e4:	85 b9       	out	0x05, r24	; 5
 1e6:	9f 91       	pop	r25
 1e8:	8f 91       	pop	r24
 1ea:	0f 90       	pop	r0
 1ec:	0f be       	out	0x3f, r0	; 63
 1ee:	0f 90       	pop	r0
 1f0:	1f 90       	pop	r1
 1f2:	18 95       	reti

000001f4 <__vector_2>:
 1f4:	1f 92       	push	r1
 1f6:	0f 92       	push	r0
 1f8:	0f b6       	in	r0, 0x3f	; 63
 1fa:	0f 92       	push	r0
 1fc:	11 24       	eor	r1, r1
 1fe:	8f 93       	push	r24
 200:	9f 93       	push	r25
 202:	83 e0       	ldi	r24, 0x03	; 3
 204:	90 e0       	ldi	r25, 0x00	; 0
 206:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 20a:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
 20e:	85 b1       	in	r24, 0x05	; 5
 210:	81 60       	ori	r24, 0x01	; 1
 212:	85 b9       	out	0x05, r24	; 5
 214:	9f 91       	pop	r25
 216:	8f 91       	pop	r24
 218:	0f 90       	pop	r0
 21a:	0f be       	out	0x3f, r0	; 63
 21c:	0f 90       	pop	r0
 21e:	1f 90       	pop	r1
 220:	18 95       	reti

00000222 <analogWriteV2>:
/*
(16 * 10^6) * (1/1024) * (7/256) = 427.2460938 Hz
*/
void analogWriteV2(int val)
{
	DDRH = (1<<DDH5) | (1<<DDH6);
 222:	20 e6       	ldi	r18, 0x60	; 96
 224:	20 93 01 01 	sts	0x0101, r18	; 0x800101 <__TEXT_REGION_LENGTH__+0x7c0101>
	
	if (val == 0)
 228:	00 97       	sbiw	r24, 0x00	; 0
 22a:	51 f4       	brne	.+20     	; 0x240 <analogWriteV2+0x1e>
	{
		TCCR2A &= (0<<COM2B1);
 22c:	e0 eb       	ldi	r30, 0xB0	; 176
 22e:	f0 e0       	ldi	r31, 0x00	; 0
 230:	20 81       	ld	r18, Z
 232:	10 82       	st	Z, r1
		TCCR4A &= (0<<COM4C1);
 234:	e0 ea       	ldi	r30, 0xA0	; 160
 236:	f0 e0       	ldi	r31, 0x00	; 0
 238:	20 81       	ld	r18, Z
 23a:	10 82       	st	Z, r1
		PORTH = (0<<PH5) & (0<<PH6);
 23c:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <__TEXT_REGION_LENGTH__+0x7c0102>
	}
	if (val == 255)
 240:	8f 3f       	cpi	r24, 0xFF	; 255
 242:	91 05       	cpc	r25, r1
 244:	21 f4       	brne	.+8      	; 0x24e <analogWriteV2+0x2c>
	{
		PORTH = (1<<PH5) | (1<<PH6);
 246:	80 e6       	ldi	r24, 0x60	; 96
 248:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x7c0102>
 24c:	08 95       	ret
	}
	else
	{
		TCCR2A |= (1<<WGM20);
 24e:	e0 eb       	ldi	r30, 0xB0	; 176
 250:	f0 e0       	ldi	r31, 0x00	; 0
 252:	20 81       	ld	r18, Z
 254:	21 60       	ori	r18, 0x01	; 1
 256:	20 83       	st	Z, r18
		TCCR2A |= (1<<COM2B1);
 258:	20 81       	ld	r18, Z
 25a:	20 62       	ori	r18, 0x20	; 32
 25c:	20 83       	st	Z, r18
		
		TCCR4A |= (1<<WGM40);
 25e:	e0 ea       	ldi	r30, 0xA0	; 160
 260:	f0 e0       	ldi	r31, 0x00	; 0
 262:	20 81       	ld	r18, Z
 264:	21 60       	ori	r18, 0x01	; 1
 266:	20 83       	st	Z, r18
		TCCR4A |= (1<<COM4C1);
 268:	20 81       	ld	r18, Z
 26a:	28 60       	ori	r18, 0x08	; 8
 26c:	20 83       	st	Z, r18
		
		//Sets the clock prescaler to divide by 1024 (clk(T2S) / 1024), page 188 of ATMega 2560 datasheet
		//TCCR2B = (1<<CS20) | (1<<CS21) | (1<<CS22);
		
		//Sets the clock prescaler to divide by 256 (clk(T2S) / 256), page 188 of ATMega 2560 datasheet
		TCCR2B = (1<<CS22) | (1<<CS21);
 26e:	26 e0       	ldi	r18, 0x06	; 6
 270:	20 93 b1 00 	sts	0x00B1, r18	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7c00b1>
		//Sets the clock prescaler to divide by 256 (clk(T4S) / 256), page 162 of ATMega 2560 datasheet
		TCCR4B |= (1<<CS42);
 274:	e1 ea       	ldi	r30, 0xA1	; 161
 276:	f0 e0       	ldi	r31, 0x00	; 0
 278:	20 81       	ld	r18, Z
 27a:	24 60       	ori	r18, 0x04	; 4
 27c:	20 83       	st	Z, r18
		//TCCR2B = (1<<CS20) | (1<<CS21);
		
		//Sets the clock prescaler to divide by 8 (clk(T2S) / 8), page 188 of ATMega 2560 datasheet
		//TCCR2B |= (1<<CS21);
		
		OCR2B = val;
 27e:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7c00b4>
		OCR4C = val;
 282:	90 93 ad 00 	sts	0x00AD, r25	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7c00ad>
 286:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7c00ac>
 28a:	08 95       	ret

0000028c <waitContinue>:
	}
}

void waitContinue() {
	//Enable interrupts on INT3
	EIMSK |= (1<<INT3);
 28c:	8d b3       	in	r24, 0x1d	; 29
 28e:	88 60       	ori	r24, 0x08	; 8
 290:	8d bb       	out	0x1d, r24	; 29
	
	sei();
 292:	78 94       	sei
	
	//Wait for CONTINUE button to be pressed
	flag = 0;
 294:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 298:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <__DATA_REGION_ORIGIN__>
	while (flag != 2)
 29c:	03 c0       	rjmp	.+6      	; 0x2a4 <waitContinue+0x18>
	{
		//Indicator LED
		PORTB |= (1<<PB5);
 29e:	85 b1       	in	r24, 0x05	; 5
 2a0:	80 62       	ori	r24, 0x20	; 32
 2a2:	85 b9       	out	0x05, r24	; 5
	
	sei();
	
	//Wait for CONTINUE button to be pressed
	flag = 0;
	while (flag != 2)
 2a4:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
 2a8:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 2ac:	02 97       	sbiw	r24, 0x02	; 2
 2ae:	b9 f7       	brne	.-18     	; 0x29e <waitContinue+0x12>
	{
		//Indicator LED
		PORTB |= (1<<PB5);
	}
	cli();
 2b0:	f8 94       	cli
 2b2:	08 95       	ret

000002b4 <wait>:
}

void wait() {
	//Enable interrupts on INT1 and INT3
	EIMSK = (1<<INT3) | (1<<INT1);
 2b4:	8a e0       	ldi	r24, 0x0A	; 10
 2b6:	8d bb       	out	0x1d, r24	; 29
	
	sei();
 2b8:	78 94       	sei
	
	//Wait for either button to be pressed
	flag = 0;
 2ba:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 2be:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <__DATA_REGION_ORIGIN__>
	while (flag != 2 && flag != 3) {
 2c2:	03 c0       	rjmp	.+6      	; 0x2ca <wait+0x16>
		//Indicator LED
		PORTB |= (1<<PB5);
 2c4:	85 b1       	in	r24, 0x05	; 5
 2c6:	80 62       	ori	r24, 0x20	; 32
 2c8:	85 b9       	out	0x05, r24	; 5
	
	sei();
	
	//Wait for either button to be pressed
	flag = 0;
	while (flag != 2 && flag != 3) {
 2ca:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
 2ce:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 2d2:	02 97       	sbiw	r24, 0x02	; 2
 2d4:	02 97       	sbiw	r24, 0x02	; 2
 2d6:	b0 f7       	brcc	.-20     	; 0x2c4 <wait+0x10>
		//Indicator LED
		PORTB |= (1<<PB5);
	}
	cli();
 2d8:	f8 94       	cli
	
	//Disable interrupts for both buttons for a brief period
	EIMSK = (0<<INT3) & (0<<INT1);
 2da:	1d ba       	out	0x1d, r1	; 29
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2dc:	2f ef       	ldi	r18, 0xFF	; 255
 2de:	86 e7       	ldi	r24, 0x76	; 118
 2e0:	91 e0       	ldi	r25, 0x01	; 1
 2e2:	21 50       	subi	r18, 0x01	; 1
 2e4:	80 40       	sbci	r24, 0x00	; 0
 2e6:	90 40       	sbci	r25, 0x00	; 0
 2e8:	e1 f7       	brne	.-8      	; 0x2e2 <wait+0x2e>
 2ea:	00 c0       	rjmp	.+0      	; 0x2ec <wait+0x38>
 2ec:	00 00       	nop
	//INT1 will never be used again for the rest of the program, so turn off the pin to save power
	//PORTD &= (0<<PD1); //OK for some reason when I uncomment this line it seems to keep triggering the INT1 ISR because INT1 is set to trigger when PD1 is low
	
	_delay_ms(30);
	PORTB &= (0<<PB0);
 2ee:	85 b1       	in	r24, 0x05	; 5
 2f0:	15 b8       	out	0x05, r1	; 5
 2f2:	08 95       	ret

000002f4 <machineInit>:
}

void machineInit() {
	cli();
 2f4:	f8 94       	cli
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Machine Setup
	
	//Set Pin 10 to output mode
	//Pin 10 Arduino Mega is STEP pin for the Linear Drive Motor
	DDRB |= (1<<DDB4);
 2f6:	84 b1       	in	r24, 0x04	; 4
 2f8:	80 61       	ori	r24, 0x10	; 16
 2fa:	84 b9       	out	0x04, r24	; 4
	
	//Pin 9 Arduino Mega is STEP pin for a Panel Motor
	DDRH |= (1<<DDH6);
 2fc:	e1 e0       	ldi	r30, 0x01	; 1
 2fe:	f1 e0       	ldi	r31, 0x01	; 1
 300:	80 81       	ld	r24, Z
 302:	80 64       	ori	r24, 0x40	; 64
 304:	80 83       	st	Z, r24
	
	//Pin 8 Arduino Mega is STEP pin for a Panel Motor
	DDRH |= (1<<DDH5);
 306:	80 81       	ld	r24, Z
 308:	80 62       	ori	r24, 0x20	; 32
 30a:	80 83       	st	Z, r24
	
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
	//Pin 5 Arduino Mega is DIR pin for the Linear Drive Motor
	DDRE |= (1<<DDE3);
 30c:	8d b1       	in	r24, 0x0d	; 13
 30e:	88 60       	ori	r24, 0x08	; 8
 310:	8d b9       	out	0x0d, r24	; 13
	
	//Pin 4 Arduino Mega is DIR pin for a Panel Motor
	DDRG |= (1<<DDG5);
 312:	83 b3       	in	r24, 0x13	; 19
 314:	80 62       	ori	r24, 0x20	; 32
 316:	83 bb       	out	0x13, r24	; 19
	
	//Pin 14 Arduino Mega is DIR pin for a Panel Motor
	DDRJ |= (1<<DDJ1);
 318:	e4 e0       	ldi	r30, 0x04	; 4
 31a:	f1 e0       	ldi	r31, 0x01	; 1
 31c:	80 81       	ld	r24, Z
 31e:	82 60       	ori	r24, 0x02	; 2
 320:	80 83       	st	Z, r24
	PINS 6, 16 AND 17 ON THE ARDUINO MEGA ARE BROKEN AND DO NOT WORK, THEY STAY LOW CONSTANTLY FOR SOME REASON I DON'T KNOW WHY so use different pins instead
	*/
	//-------------------------------------------------------------------------------------------------------
	//Clockwise rotation moves panel forward & Counterclockwise rotation moves panel backwards
	//When DIR is high, linear drive motor rotates clockwise and moves panel forward
	PORTE |= (1<<PE3);
 322:	8e b1       	in	r24, 0x0e	; 14
 324:	88 60       	ori	r24, 0x08	; 8
 326:	8e b9       	out	0x0e, r24	; 14
	//Keep Panel direction pins LOW (or HIGH), whichever direction has less gear slipping
	//PORTG &= (0<<PG5);
	//PORTJ &= (0<<PJ1);
	PORTG |= (1<<PG5);
 328:	84 b3       	in	r24, 0x14	; 20
 32a:	80 62       	ori	r24, 0x20	; 32
 32c:	84 bb       	out	0x14, r24	; 20
	PORTJ |= (1<<PJ1);
 32e:	e5 e0       	ldi	r30, 0x05	; 5
 330:	f1 e0       	ldi	r31, 0x01	; 1
 332:	80 81       	ld	r24, Z
 334:	82 60       	ori	r24, 0x02	; 2
 336:	80 83       	st	Z, r24
	//-------------------------------------------------------------------------------------------------------
	//Make sure INT1/INT2/INT3 pins is in input mode with the internal pullup resistors enabled
	DDRD = (0<<DDD3) & (0<<DDD2) & (0<<DDD1);
 338:	1a b8       	out	0x0a, r1	; 10
	PORTD = (1<<PD3) | (1<<PD2) | (1<<PD1);
 33a:	8e e0       	ldi	r24, 0x0E	; 14
 33c:	8b b9       	out	0x0b, r24	; 11
	
	//DDRE &= (0<<DDE5);
	//PORTE |= (1<<PE5);
	
	MCUCR &= (0<<PUD);
 33e:	85 b7       	in	r24, 0x35	; 53
 340:	15 be       	out	0x35, r1	; 53
	//-------------------------------------------------------------------------------------------------------
	
	//Beginning sample display indicator
	DDRL |= (1<<DDL0);
 342:	ea e0       	ldi	r30, 0x0A	; 10
 344:	f1 e0       	ldi	r31, 0x01	; 1
 346:	80 81       	ld	r24, Z
 348:	81 60       	ori	r24, 0x01	; 1
 34a:	80 83       	st	Z, r24
	PORTL &= (0<<PL0);
 34c:	eb e0       	ldi	r30, 0x0B	; 11
 34e:	f1 e0       	ldi	r31, 0x01	; 1
 350:	80 81       	ld	r24, Z
 352:	10 82       	st	Z, r1
	
	//Startup indicator
	for (int i = 0; i < 2; i++)
 354:	80 e0       	ldi	r24, 0x00	; 0
 356:	90 e0       	ldi	r25, 0x00	; 0
 358:	1a c0       	rjmp	.+52     	; 0x38e <machineInit+0x9a>
	{
		PORTL |= (1<<PL0);
 35a:	eb e0       	ldi	r30, 0x0B	; 11
 35c:	f1 e0       	ldi	r31, 0x01	; 1
 35e:	20 81       	ld	r18, Z
 360:	21 60       	ori	r18, 0x01	; 1
 362:	20 83       	st	Z, r18
 364:	2f ef       	ldi	r18, 0xFF	; 255
 366:	35 ea       	ldi	r19, 0xA5	; 165
 368:	4e e0       	ldi	r20, 0x0E	; 14
 36a:	21 50       	subi	r18, 0x01	; 1
 36c:	30 40       	sbci	r19, 0x00	; 0
 36e:	40 40       	sbci	r20, 0x00	; 0
 370:	e1 f7       	brne	.-8      	; 0x36a <machineInit+0x76>
 372:	00 c0       	rjmp	.+0      	; 0x374 <machineInit+0x80>
 374:	00 00       	nop
		_delay_ms(300);
		PORTL &= (0<<PL0);
 376:	20 81       	ld	r18, Z
 378:	10 82       	st	Z, r1
 37a:	2f ef       	ldi	r18, 0xFF	; 255
 37c:	35 ea       	ldi	r19, 0xA5	; 165
 37e:	4e e0       	ldi	r20, 0x0E	; 14
 380:	21 50       	subi	r18, 0x01	; 1
 382:	30 40       	sbci	r19, 0x00	; 0
 384:	40 40       	sbci	r20, 0x00	; 0
 386:	e1 f7       	brne	.-8      	; 0x380 <machineInit+0x8c>
 388:	00 c0       	rjmp	.+0      	; 0x38a <machineInit+0x96>
 38a:	00 00       	nop
	//Beginning sample display indicator
	DDRL |= (1<<DDL0);
	PORTL &= (0<<PL0);
	
	//Startup indicator
	for (int i = 0; i < 2; i++)
 38c:	01 96       	adiw	r24, 0x01	; 1
 38e:	82 30       	cpi	r24, 0x02	; 2
 390:	91 05       	cpc	r25, r1
 392:	1c f3       	brlt	.-58     	; 0x35a <machineInit+0x66>
		_delay_ms(300);
	}
	
	
	//Button pressed indicator LED (green) will be on Pin 53 on the Arduino Mega
	DDRB |= (1<<DDB0);
 394:	84 b1       	in	r24, 0x04	; 4
 396:	81 60       	ori	r24, 0x01	; 1
 398:	84 b9       	out	0x04, r24	; 4
	PORTB &= (0<<PB0);
 39a:	85 b1       	in	r24, 0x05	; 5
 39c:	15 b8       	out	0x05, r1	; 5
	
	//Startup indicator
	for (int i = 0; i < 2; i++)
 39e:	80 e0       	ldi	r24, 0x00	; 0
 3a0:	90 e0       	ldi	r25, 0x00	; 0
 3a2:	18 c0       	rjmp	.+48     	; 0x3d4 <machineInit+0xe0>
	{
		PORTB |= (1<<PB0);
 3a4:	25 b1       	in	r18, 0x05	; 5
 3a6:	21 60       	ori	r18, 0x01	; 1
 3a8:	25 b9       	out	0x05, r18	; 5
 3aa:	2f ef       	ldi	r18, 0xFF	; 255
 3ac:	35 ea       	ldi	r19, 0xA5	; 165
 3ae:	4e e0       	ldi	r20, 0x0E	; 14
 3b0:	21 50       	subi	r18, 0x01	; 1
 3b2:	30 40       	sbci	r19, 0x00	; 0
 3b4:	40 40       	sbci	r20, 0x00	; 0
 3b6:	e1 f7       	brne	.-8      	; 0x3b0 <machineInit+0xbc>
 3b8:	00 c0       	rjmp	.+0      	; 0x3ba <machineInit+0xc6>
 3ba:	00 00       	nop
		_delay_ms(300);
		PORTB &= (0<<PB0);
 3bc:	25 b1       	in	r18, 0x05	; 5
 3be:	15 b8       	out	0x05, r1	; 5
 3c0:	2f ef       	ldi	r18, 0xFF	; 255
 3c2:	35 ea       	ldi	r19, 0xA5	; 165
 3c4:	4e e0       	ldi	r20, 0x0E	; 14
 3c6:	21 50       	subi	r18, 0x01	; 1
 3c8:	30 40       	sbci	r19, 0x00	; 0
 3ca:	40 40       	sbci	r20, 0x00	; 0
 3cc:	e1 f7       	brne	.-8      	; 0x3c6 <machineInit+0xd2>
 3ce:	00 c0       	rjmp	.+0      	; 0x3d0 <machineInit+0xdc>
 3d0:	00 00       	nop
	//Button pressed indicator LED (green) will be on Pin 53 on the Arduino Mega
	DDRB |= (1<<DDB0);
	PORTB &= (0<<PB0);
	
	//Startup indicator
	for (int i = 0; i < 2; i++)
 3d2:	01 96       	adiw	r24, 0x01	; 1
 3d4:	82 30       	cpi	r24, 0x02	; 2
 3d6:	91 05       	cpc	r25, r1
 3d8:	2c f3       	brlt	.-54     	; 0x3a4 <machineInit+0xb0>
		_delay_ms(300);
	}
	
	
	//Startup indicator LED will be on Pin 11 on the Arduino Mega
	DDRB |= (1<<DDB5);
 3da:	84 b1       	in	r24, 0x04	; 4
 3dc:	80 62       	ori	r24, 0x20	; 32
 3de:	84 b9       	out	0x04, r24	; 4
	PORTB &= (0<<PB5);
 3e0:	85 b1       	in	r24, 0x05	; 5
 3e2:	15 b8       	out	0x05, r1	; 5
	
	//Startup indicator
	for (int i = 0; i < 3; i++)
 3e4:	20 e0       	ldi	r18, 0x00	; 0
 3e6:	30 e0       	ldi	r19, 0x00	; 0
 3e8:	19 c0       	rjmp	.+50     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
	{
		PORTB |= (1<<PB5);
 3ea:	85 b1       	in	r24, 0x05	; 5
 3ec:	80 62       	ori	r24, 0x20	; 32
 3ee:	85 b9       	out	0x05, r24	; 5
 3f0:	8f ef       	ldi	r24, 0xFF	; 255
 3f2:	95 ea       	ldi	r25, 0xA5	; 165
 3f4:	4e e0       	ldi	r20, 0x0E	; 14
 3f6:	81 50       	subi	r24, 0x01	; 1
 3f8:	90 40       	sbci	r25, 0x00	; 0
 3fa:	40 40       	sbci	r20, 0x00	; 0
 3fc:	e1 f7       	brne	.-8      	; 0x3f6 <machineInit+0x102>
 3fe:	00 c0       	rjmp	.+0      	; 0x400 <__LOCK_REGION_LENGTH__>
 400:	00 00       	nop
		_delay_ms(300);
		PORTB &= (0<<PB5);
 402:	85 b1       	in	r24, 0x05	; 5
 404:	15 b8       	out	0x05, r1	; 5
 406:	8f ef       	ldi	r24, 0xFF	; 255
 408:	95 ea       	ldi	r25, 0xA5	; 165
 40a:	4e e0       	ldi	r20, 0x0E	; 14
 40c:	81 50       	subi	r24, 0x01	; 1
 40e:	90 40       	sbci	r25, 0x00	; 0
 410:	40 40       	sbci	r20, 0x00	; 0
 412:	e1 f7       	brne	.-8      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
 414:	00 c0       	rjmp	.+0      	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
 416:	00 00       	nop
	//Startup indicator LED will be on Pin 11 on the Arduino Mega
	DDRB |= (1<<DDB5);
	PORTB &= (0<<PB5);
	
	//Startup indicator
	for (int i = 0; i < 3; i++)
 418:	2f 5f       	subi	r18, 0xFF	; 255
 41a:	3f 4f       	sbci	r19, 0xFF	; 255
 41c:	23 30       	cpi	r18, 0x03	; 3
 41e:	31 05       	cpc	r19, r1
 420:	24 f3       	brlt	.-56     	; 0x3ea <machineInit+0xf6>
 422:	8f ef       	ldi	r24, 0xFF	; 255
 424:	93 ed       	ldi	r25, 0xD3	; 211
 426:	20 e3       	ldi	r18, 0x30	; 48
 428:	81 50       	subi	r24, 0x01	; 1
 42a:	90 40       	sbci	r25, 0x00	; 0
 42c:	20 40       	sbci	r18, 0x00	; 0
 42e:	e1 f7       	brne	.-8      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
 430:	00 c0       	rjmp	.+0      	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
 432:	00 00       	nop
		_delay_ms(300);
	}
	_delay_ms(1000);
	//-------------------------------------------------------------------------------------------------------
	//Low level on INT1, INT2, and INT3 each trigger an interrupt (page 76 of ATmega2560 datasheet)
	EICRA = (0<<ISC31) & (0<<ISC30) & (0<<ISC21) & (0<<ISC20) & (0<<ISC11) & (0<<ISC10);
 434:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7c0069>
	//EICRB = (0<<ISC51) & (0<<ISC50);
	
	//Enable interrupts on INT1 and INT2
	EIMSK = (1<<INT2) | (1<<INT1);
 438:	86 e0       	ldi	r24, 0x06	; 6
 43a:	8d bb       	out	0x1d, r24	; 29
 43c:	08 95       	ret

0000043e <home>:
	//EIMSK |= (1<<INT2);
}

void home() {
	//Homing sequence
	sei();
 43e:	78 94       	sei
	flag = 0;
 440:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 444:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <__DATA_REGION_ORIGIN__>
	while (flag != 1)
 448:	11 c0       	rjmp	.+34     	; 0x46c <home+0x2e>
	{
		PORTB |= (1<<PB4);
 44a:	85 b1       	in	r24, 0x05	; 5
 44c:	80 61       	ori	r24, 0x10	; 16
 44e:	85 b9       	out	0x05, r24	; 5
 450:	87 e8       	ldi	r24, 0x87	; 135
 452:	93 e1       	ldi	r25, 0x13	; 19
 454:	01 97       	sbiw	r24, 0x01	; 1
 456:	f1 f7       	brne	.-4      	; 0x454 <home+0x16>
 458:	00 c0       	rjmp	.+0      	; 0x45a <home+0x1c>
 45a:	00 00       	nop
		_delay_ms(1.250);
		PORTB &= (0<<PB4);
 45c:	85 b1       	in	r24, 0x05	; 5
 45e:	15 b8       	out	0x05, r1	; 5
 460:	87 e8       	ldi	r24, 0x87	; 135
 462:	93 e1       	ldi	r25, 0x13	; 19
 464:	01 97       	sbiw	r24, 0x01	; 1
 466:	f1 f7       	brne	.-4      	; 0x464 <home+0x26>
 468:	00 c0       	rjmp	.+0      	; 0x46a <home+0x2c>
 46a:	00 00       	nop

void home() {
	//Homing sequence
	sei();
	flag = 0;
	while (flag != 1)
 46c:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
 470:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 474:	01 97       	sbiw	r24, 0x01	; 1
 476:	49 f7       	brne	.-46     	; 0x44a <home+0xc>
		PORTB |= (1<<PB4);
		_delay_ms(1.250);
		PORTB &= (0<<PB4);
		_delay_ms(1.250);
	}
	cli();
 478:	f8 94       	cli
	
	
	//Disable interrupts for homing endstop
	EIMSK &= (0<<INT2);
 47a:	8d b3       	in	r24, 0x1d	; 29
 47c:	1d ba       	out	0x1d, r1	; 29
 47e:	08 95       	ret

00000480 <stretch>:

void stretch() {
	//Precursor Fiber Stretching
	
	//Invert the direction of the linear drive motor so that the panel mechanism moves backwards
	PORTE &= (0<<PE3);
 480:	8e b1       	in	r24, 0x0e	; 14
 482:	1e b8       	out	0x0e, r1	; 14
 484:	2f ef       	ldi	r18, 0xFF	; 255
 486:	89 e6       	ldi	r24, 0x69	; 105
 488:	98 e1       	ldi	r25, 0x18	; 24
 48a:	21 50       	subi	r18, 0x01	; 1
 48c:	80 40       	sbci	r24, 0x00	; 0
 48e:	90 40       	sbci	r25, 0x00	; 0
 490:	e1 f7       	brne	.-8      	; 0x48a <stretch+0xa>
 492:	00 c0       	rjmp	.+0      	; 0x494 <stretch+0x14>
 494:	00 00       	nop
	
	//Wait a moment before beginning backwards movement so that it doesn't jerk the whole mechanism
	_delay_ms(500);
	
	sei();
 496:	78 94       	sei
	int steps = ((int)(full_rot * ((distance - (offset + exp_offset)) / lead)));
	int thres_slow = steps * 0.75;
	int thres_slowest = steps * 0.95;
	
	//Move backwards the required distance to stretch the precursor fibers to ~0.731 N of tension
	for (int i = 0; i < steps; i++)
 498:	40 e0       	ldi	r20, 0x00	; 0
 49a:	50 e0       	ldi	r21, 0x00	; 0
	use the default homing speed and square wave period of 1250us and it will disable speed control.
	
	*/
	
	
	int scaler = 3; //1
 49c:	23 e0       	ldi	r18, 0x03	; 3
 49e:	30 e0       	ldi	r19, 0x00	; 0
	int steps = ((int)(full_rot * ((distance - (offset + exp_offset)) / lead)));
	int thres_slow = steps * 0.75;
	int thres_slowest = steps * 0.95;
	
	//Move backwards the required distance to stretch the precursor fibers to ~0.731 N of tension
	for (int i = 0; i < steps; i++)
 4a0:	2d c0       	rjmp	.+90     	; 0x4fc <stretch+0x7c>
	{
		PORTB |= (1<<PB4);
 4a2:	85 b1       	in	r24, 0x05	; 5
 4a4:	80 61       	ori	r24, 0x10	; 16
 4a6:	85 b9       	out	0x05, r24	; 5
		for (int j = 0; j < scaler; j++)
 4a8:	80 e0       	ldi	r24, 0x00	; 0
 4aa:	90 e0       	ldi	r25, 0x00	; 0
 4ac:	07 c0       	rjmp	.+14     	; 0x4bc <stretch+0x3c>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4ae:	ef e1       	ldi	r30, 0x1F	; 31
 4b0:	f3 e0       	ldi	r31, 0x03	; 3
 4b2:	31 97       	sbiw	r30, 0x01	; 1
 4b4:	f1 f7       	brne	.-4      	; 0x4b2 <stretch+0x32>
 4b6:	00 c0       	rjmp	.+0      	; 0x4b8 <stretch+0x38>
 4b8:	00 00       	nop
 4ba:	01 96       	adiw	r24, 0x01	; 1
 4bc:	82 17       	cp	r24, r18
 4be:	93 07       	cpc	r25, r19
 4c0:	b4 f3       	brlt	.-20     	; 0x4ae <stretch+0x2e>
		{
			//_delay_ms(1.250);
			_delay_us(200);
		}
		//The only reason I am putting this if statement here and not with the other one is because the comparison between i and thres_slow takes time, just like the comp. between i and thres_slowest. This might make the square wave slightly more even
		if (i >= thres_slow)
 4c2:	44 37       	cpi	r20, 0x74	; 116
 4c4:	f2 e5       	ldi	r31, 0x52	; 82
 4c6:	5f 07       	cpc	r21, r31
 4c8:	14 f0       	brlt	.+4      	; 0x4ce <stretch+0x4e>
		{
			scaler = 6;
 4ca:	26 e0       	ldi	r18, 0x06	; 6
 4cc:	30 e0       	ldi	r19, 0x00	; 0
		}
		PORTB &= (0<<PB4);
 4ce:	85 b1       	in	r24, 0x05	; 5
 4d0:	15 b8       	out	0x05, r1	; 5
		for (int j = 0; j < scaler; j++)
 4d2:	80 e0       	ldi	r24, 0x00	; 0
 4d4:	90 e0       	ldi	r25, 0x00	; 0
 4d6:	07 c0       	rjmp	.+14     	; 0x4e6 <stretch+0x66>
 4d8:	ef e1       	ldi	r30, 0x1F	; 31
 4da:	f3 e0       	ldi	r31, 0x03	; 3
 4dc:	31 97       	sbiw	r30, 0x01	; 1
 4de:	f1 f7       	brne	.-4      	; 0x4dc <stretch+0x5c>
 4e0:	00 c0       	rjmp	.+0      	; 0x4e2 <stretch+0x62>
 4e2:	00 00       	nop
 4e4:	01 96       	adiw	r24, 0x01	; 1
 4e6:	82 17       	cp	r24, r18
 4e8:	93 07       	cpc	r25, r19
 4ea:	b4 f3       	brlt	.-20     	; 0x4d8 <stretch+0x58>
		{
			//_delay_ms(1.250);
			_delay_us(200);
		}
		if (i >= thres_slowest) //Slows down the stepper as it gets very close to the required distance, just to make sure it doesn't over or undershoot the distance by much
 4ec:	41 37       	cpi	r20, 0x71	; 113
 4ee:	f8 e6       	ldi	r31, 0x68	; 104
 4f0:	5f 07       	cpc	r21, r31
 4f2:	14 f0       	brlt	.+4      	; 0x4f8 <stretch+0x78>
		{
			scaler = 44; //7
 4f4:	2c e2       	ldi	r18, 0x2C	; 44
 4f6:	30 e0       	ldi	r19, 0x00	; 0
	int steps = ((int)(full_rot * ((distance - (offset + exp_offset)) / lead)));
	int thres_slow = steps * 0.75;
	int thres_slowest = steps * 0.95;
	
	//Move backwards the required distance to stretch the precursor fibers to ~0.731 N of tension
	for (int i = 0; i < steps; i++)
 4f8:	4f 5f       	subi	r20, 0xFF	; 255
 4fa:	5f 4f       	sbci	r21, 0xFF	; 255
 4fc:	41 3f       	cpi	r20, 0xF1	; 241
 4fe:	8d e6       	ldi	r24, 0x6D	; 109
 500:	58 07       	cpc	r21, r24
 502:	7c f2       	brlt	.-98     	; 0x4a2 <stretch+0x22>
			scaler = 44; //7
		}
	}
	
	
	cli();
 504:	f8 94       	cli
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 506:	9f ef       	ldi	r25, 0xFF	; 255
 508:	e9 e6       	ldi	r30, 0x69	; 105
 50a:	f8 e1       	ldi	r31, 0x18	; 24
 50c:	91 50       	subi	r25, 0x01	; 1
 50e:	e0 40       	sbci	r30, 0x00	; 0
 510:	f0 40       	sbci	r31, 0x00	; 0
 512:	e1 f7       	brne	.-8      	; 0x50c <stretch+0x8c>
 514:	00 c0       	rjmp	.+0      	; 0x516 <stretch+0x96>
 516:	00 00       	nop
	
	//Added delay so that one button press doesn't accidentally count as multiple and skip through phases of machine operation
	_delay_ms(500);
	
	//Set the direction of the linear drive so that the panel mechanism moves forwards towards the other panel
	PORTE |= (1<<PE3);
 518:	8e b1       	in	r24, 0x0e	; 14
 51a:	88 60       	ori	r24, 0x08	; 8
 51c:	8e b9       	out	0x0e, r24	; 14
 51e:	08 95       	ret

00000520 <twist>:
}

void twist() {
	//Begin Precursor Fiber Twisting
	
	waitContinue();
 520:	b5 de       	rcall	.-662    	; 0x28c <waitContinue>
	
	PORTB &= (0<<PB5);
 522:	85 b1       	in	r24, 0x05	; 5
 524:	15 b8       	out	0x05, r1	; 5
 526:	2f ef       	ldi	r18, 0xFF	; 255
 528:	36 e7       	ldi	r19, 0x76	; 118
 52a:	41 e0       	ldi	r20, 0x01	; 1
 52c:	21 50       	subi	r18, 0x01	; 1
 52e:	30 40       	sbci	r19, 0x00	; 0
 530:	40 40       	sbci	r20, 0x00	; 0
 532:	e1 f7       	brne	.-8      	; 0x52c <twist+0xc>
 534:	00 c0       	rjmp	.+0      	; 0x536 <twist+0x16>
 536:	00 00       	nop
	
	_delay_ms(30);
	PORTB &= (0<<PB0);
 538:	85 b1       	in	r24, 0x05	; 5
 53a:	15 b8       	out	0x05, r1	; 5
	
	//Begin Panel Motor movement
	analogWriteV2(128);
 53c:	80 e8       	ldi	r24, 0x80	; 128
 53e:	90 e0       	ldi	r25, 0x00	; 0
 540:	70 de       	rcall	.-800    	; 0x222 <analogWriteV2>
	
	//When the clock prescalers in analogWriteV2() are set to 256, it takes 57.25 seconds for 35 full rotations of each loop gear. The muscles need to be twisted 35 times before activating the linear drive motor.
	//57.25 seconds == 57250 milliseconds, and (57250 / 250) = 229
	//You should change this for loop to a different delay time whenever you change the clock prescaler in analogWriteV2().
	for (int i = 0; i < 229; i++)
 542:	80 e0       	ldi	r24, 0x00	; 0
 544:	90 e0       	ldi	r25, 0x00	; 0
 546:	0a c0       	rjmp	.+20     	; 0x55c <twist+0x3c>
 548:	2f ef       	ldi	r18, 0xFF	; 255
 54a:	34 e3       	ldi	r19, 0x34	; 52
 54c:	4c e0       	ldi	r20, 0x0C	; 12
 54e:	21 50       	subi	r18, 0x01	; 1
 550:	30 40       	sbci	r19, 0x00	; 0
 552:	40 40       	sbci	r20, 0x00	; 0
 554:	e1 f7       	brne	.-8      	; 0x54e <twist+0x2e>
 556:	00 c0       	rjmp	.+0      	; 0x558 <twist+0x38>
 558:	00 00       	nop
 55a:	01 96       	adiw	r24, 0x01	; 1
 55c:	85 3e       	cpi	r24, 0xE5	; 229
 55e:	91 05       	cpc	r25, r1
 560:	9c f3       	brlt	.-26     	; 0x548 <twist+0x28>
	{
		_delay_ms(250);
	}
}
 562:	08 95       	ret

00000564 <move>:
	
	//==============================
	//Implement speed control below
	
	//Indicator LED on
	PORTB |= (1<<PB5);
 564:	85 b1       	in	r24, 0x05	; 5
 566:	80 62       	ori	r24, 0x20	; 32
 568:	85 b9       	out	0x05, r24	; 5
	//accelerate_LinearDrive(823, 423);
	
	//Begin linear drive movement and speed control loop 1
	//The potentiometer value to initiate coiling in this section of the code is 353, so to get the calculated delay value of 4230us that I am using here, I simply did 10(353 + 70) by replacing sampVal with 353
	//During calibration, I found that the proper time the linear drive should move at the initial speed before speeding up is 89893ms, or 89.893s. (89893 / (2 * 4.850)) = 9267.319588, or ~9267
	for (int i = 0; i < 9267; i++)
 56a:	20 e0       	ldi	r18, 0x00	; 0
 56c:	30 e0       	ldi	r19, 0x00	; 0
 56e:	1d c0       	rjmp	.+58     	; 0x5aa <move+0x46>
	{
		PORTB |= (1<<PB4);
 570:	85 b1       	in	r24, 0x05	; 5
 572:	80 61       	ori	r24, 0x10	; 16
 574:	85 b9       	out	0x05, r24	; 5
		for (uint8_t i = 0; i < 10; i++)
 576:	80 e0       	ldi	r24, 0x00	; 0
 578:	07 c0       	rjmp	.+14     	; 0x588 <move+0x24>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 57a:	e3 e9       	ldi	r30, 0x93	; 147
 57c:	f7 e0       	ldi	r31, 0x07	; 7
 57e:	31 97       	sbiw	r30, 0x01	; 1
 580:	f1 f7       	brne	.-4      	; 0x57e <move+0x1a>
 582:	00 c0       	rjmp	.+0      	; 0x584 <move+0x20>
 584:	00 00       	nop
 586:	8f 5f       	subi	r24, 0xFF	; 255
 588:	8a 30       	cpi	r24, 0x0A	; 10
 58a:	b8 f3       	brcs	.-18     	; 0x57a <move+0x16>
		{
			_delay_us(485); //423
		}
		PORTB &= (0<<PB4);
 58c:	85 b1       	in	r24, 0x05	; 5
 58e:	15 b8       	out	0x05, r1	; 5
		for (uint8_t i = 0; i < 10; i++)
 590:	80 e0       	ldi	r24, 0x00	; 0
 592:	07 c0       	rjmp	.+14     	; 0x5a2 <move+0x3e>
 594:	e3 e9       	ldi	r30, 0x93	; 147
 596:	f7 e0       	ldi	r31, 0x07	; 7
 598:	31 97       	sbiw	r30, 0x01	; 1
 59a:	f1 f7       	brne	.-4      	; 0x598 <move+0x34>
 59c:	00 c0       	rjmp	.+0      	; 0x59e <move+0x3a>
 59e:	00 00       	nop
 5a0:	8f 5f       	subi	r24, 0xFF	; 255
 5a2:	8a 30       	cpi	r24, 0x0A	; 10
 5a4:	b8 f3       	brcs	.-18     	; 0x594 <move+0x30>
	//accelerate_LinearDrive(823, 423);
	
	//Begin linear drive movement and speed control loop 1
	//The potentiometer value to initiate coiling in this section of the code is 353, so to get the calculated delay value of 4230us that I am using here, I simply did 10(353 + 70) by replacing sampVal with 353
	//During calibration, I found that the proper time the linear drive should move at the initial speed before speeding up is 89893ms, or 89.893s. (89893 / (2 * 4.850)) = 9267.319588, or ~9267
	for (int i = 0; i < 9267; i++)
 5a6:	2f 5f       	subi	r18, 0xFF	; 255
 5a8:	3f 4f       	sbci	r19, 0xFF	; 255
 5aa:	23 33       	cpi	r18, 0x33	; 51
 5ac:	f4 e2       	ldi	r31, 0x24	; 36
 5ae:	3f 07       	cpc	r19, r31
 5b0:	fc f2       	brlt	.-66     	; 0x570 <move+0xc>
 5b2:	20 e0       	ldi	r18, 0x00	; 0
 5b4:	30 e0       	ldi	r19, 0x00	; 0
 5b6:	1d c0       	rjmp	.+58     	; 0x5f2 <move+0x8e>
	//Begin linear drive movement and speed control loop 2
	//The potentiometer value to sustain coiling in this section of the code is 108, so to get the calculated delay value of 1780us that I am using here, I simply did 10(108 + 70) by replacing sampVal with 108
	//During calibration, I found that the proper time the linear drive should move at the final speed before stopping all linear drive movement is ~64912ms, or ~64.912s. (64912 / (2 * 2.000)) = 16228
	for (int i = 0; i < 16228; i++)
	{
		PORTB |= (1<<PB4);
 5b8:	85 b1       	in	r24, 0x05	; 5
 5ba:	80 61       	ori	r24, 0x10	; 16
 5bc:	85 b9       	out	0x05, r24	; 5
		for (uint8_t i = 0; i < 10; i++)
 5be:	80 e0       	ldi	r24, 0x00	; 0
 5c0:	07 c0       	rjmp	.+14     	; 0x5d0 <move+0x6c>
 5c2:	ef e1       	ldi	r30, 0x1F	; 31
 5c4:	f3 e0       	ldi	r31, 0x03	; 3
 5c6:	31 97       	sbiw	r30, 0x01	; 1
 5c8:	f1 f7       	brne	.-4      	; 0x5c6 <move+0x62>
 5ca:	00 c0       	rjmp	.+0      	; 0x5cc <move+0x68>
 5cc:	00 00       	nop
 5ce:	8f 5f       	subi	r24, 0xFF	; 255
 5d0:	8a 30       	cpi	r24, 0x0A	; 10
 5d2:	b8 f3       	brcs	.-18     	; 0x5c2 <move+0x5e>
		{
			_delay_us(200); //178
		}
		PORTB &= (0<<PB4);
 5d4:	85 b1       	in	r24, 0x05	; 5
 5d6:	15 b8       	out	0x05, r1	; 5
		for (uint8_t i = 0; i < 10; i++)
 5d8:	80 e0       	ldi	r24, 0x00	; 0
 5da:	07 c0       	rjmp	.+14     	; 0x5ea <move+0x86>
 5dc:	ef e1       	ldi	r30, 0x1F	; 31
 5de:	f3 e0       	ldi	r31, 0x03	; 3
 5e0:	31 97       	sbiw	r30, 0x01	; 1
 5e2:	f1 f7       	brne	.-4      	; 0x5e0 <move+0x7c>
 5e4:	00 c0       	rjmp	.+0      	; 0x5e6 <move+0x82>
 5e6:	00 00       	nop
 5e8:	8f 5f       	subi	r24, 0xFF	; 255
 5ea:	8a 30       	cpi	r24, 0x0A	; 10
 5ec:	b8 f3       	brcs	.-18     	; 0x5dc <move+0x78>
	//accelerate_LinearDrive(423, 200); //(423, 178)
	
	//Begin linear drive movement and speed control loop 2
	//The potentiometer value to sustain coiling in this section of the code is 108, so to get the calculated delay value of 1780us that I am using here, I simply did 10(108 + 70) by replacing sampVal with 108
	//During calibration, I found that the proper time the linear drive should move at the final speed before stopping all linear drive movement is ~64912ms, or ~64.912s. (64912 / (2 * 2.000)) = 16228
	for (int i = 0; i < 16228; i++)
 5ee:	2f 5f       	subi	r18, 0xFF	; 255
 5f0:	3f 4f       	sbci	r19, 0xFF	; 255
 5f2:	24 36       	cpi	r18, 0x64	; 100
 5f4:	ff e3       	ldi	r31, 0x3F	; 63
 5f6:	3f 07       	cpc	r19, r31
 5f8:	fc f2       	brlt	.-66     	; 0x5b8 <move+0x54>
			_delay_us(200); //178
		}
	}
	//==============================
	*/
}
 5fa:	08 95       	ret

000005fc <stop>:
void stop() {
	//Record the second time
	//times[1] = millis();
	
	//Stop panel movement, linear drive movement is already stopped
	analogWriteV2(0);
 5fc:	80 e0       	ldi	r24, 0x00	; 0
 5fe:	90 e0       	ldi	r25, 0x00	; 0
 600:	10 de       	rcall	.-992    	; 0x222 <analogWriteV2>
	
	//Indicator LED off
	PORTB &= (0<<PB5);
 602:	85 b1       	in	r24, 0x05	; 5
 604:	15 b8       	out	0x05, r1	; 5
	//_delay_ms(30);
	//PORTB &= (0<<PB0);
	
	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	//Indicator
	for (int i = 0; i < 5; i++)
 606:	20 e0       	ldi	r18, 0x00	; 0
 608:	30 e0       	ldi	r19, 0x00	; 0
 60a:	19 c0       	rjmp	.+50     	; 0x63e <stop+0x42>
	{
		PORTB |= (1<<PB0);
 60c:	85 b1       	in	r24, 0x05	; 5
 60e:	81 60       	ori	r24, 0x01	; 1
 610:	85 b9       	out	0x05, r24	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 612:	4f ef       	ldi	r20, 0xFF	; 255
 614:	85 ea       	ldi	r24, 0xA5	; 165
 616:	9e e0       	ldi	r25, 0x0E	; 14
 618:	41 50       	subi	r20, 0x01	; 1
 61a:	80 40       	sbci	r24, 0x00	; 0
 61c:	90 40       	sbci	r25, 0x00	; 0
 61e:	e1 f7       	brne	.-8      	; 0x618 <stop+0x1c>
 620:	00 c0       	rjmp	.+0      	; 0x622 <stop+0x26>
 622:	00 00       	nop
		_delay_ms(300);
		PORTB &= (0<<PB0);
 624:	85 b1       	in	r24, 0x05	; 5
 626:	15 b8       	out	0x05, r1	; 5
 628:	4f ef       	ldi	r20, 0xFF	; 255
 62a:	85 ea       	ldi	r24, 0xA5	; 165
 62c:	9e e0       	ldi	r25, 0x0E	; 14
 62e:	41 50       	subi	r20, 0x01	; 1
 630:	80 40       	sbci	r24, 0x00	; 0
 632:	90 40       	sbci	r25, 0x00	; 0
 634:	e1 f7       	brne	.-8      	; 0x62e <stop+0x32>
 636:	00 c0       	rjmp	.+0      	; 0x638 <stop+0x3c>
 638:	00 00       	nop
	//_delay_ms(30);
	//PORTB &= (0<<PB0);
	
	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	//Indicator
	for (int i = 0; i < 5; i++)
 63a:	2f 5f       	subi	r18, 0xFF	; 255
 63c:	3f 4f       	sbci	r19, 0xFF	; 255
 63e:	25 30       	cpi	r18, 0x05	; 5
 640:	31 05       	cpc	r19, r1
 642:	24 f3       	brlt	.-56     	; 0x60c <stop+0x10>
		PORTB &= (0<<PB0);
		_delay_ms(300);
	}
	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	
	PORTB |= (1<<PB5);
 644:	85 b1       	in	r24, 0x05	; 5
 646:	80 62       	ori	r24, 0x20	; 32
 648:	85 b9       	out	0x05, r24	; 5
 64a:	08 95       	ret

0000064c <wrapHeatingElement>:

void wrapHeatingElement() {
	//Stretch newly formed muscles slightly before wrapping heating element
	
	//Invert the direction of the linear drive motor so that the panel mechanism moves backwards
	PORTE &= (0<<PE3);
 64c:	8e b1       	in	r24, 0x0e	; 14
 64e:	1e b8       	out	0x0e, r1	; 14
 650:	2f ef       	ldi	r18, 0xFF	; 255
 652:	89 e6       	ldi	r24, 0x69	; 105
 654:	98 e1       	ldi	r25, 0x18	; 24
 656:	21 50       	subi	r18, 0x01	; 1
 658:	80 40       	sbci	r24, 0x00	; 0
 65a:	90 40       	sbci	r25, 0x00	; 0
 65c:	e1 f7       	brne	.-8      	; 0x656 <wrapHeatingElement+0xa>
 65e:	00 c0       	rjmp	.+0      	; 0x660 <wrapHeatingElement+0x14>
 660:	00 00       	nop
	//Wait a moment before beginning backwards movement so that it doesn't jerk the whole mechanism
	_delay_ms(500);
	
	for (int i = 0; i < ((int)(full_rot * (18 / lead))); i++) //Stretch muscle 18 mm starting from the home position before wrapping heating element
 662:	20 e0       	ldi	r18, 0x00	; 0
 664:	30 e0       	ldi	r19, 0x00	; 0
 666:	13 c0       	rjmp	.+38     	; 0x68e <wrapHeatingElement+0x42>
	{
		PORTB |= (1<<PB4);
 668:	85 b1       	in	r24, 0x05	; 5
 66a:	80 61       	ori	r24, 0x10	; 16
 66c:	85 b9       	out	0x05, r24	; 5
 66e:	87 e8       	ldi	r24, 0x87	; 135
 670:	93 e1       	ldi	r25, 0x13	; 19
 672:	01 97       	sbiw	r24, 0x01	; 1
 674:	f1 f7       	brne	.-4      	; 0x672 <wrapHeatingElement+0x26>
 676:	00 c0       	rjmp	.+0      	; 0x678 <wrapHeatingElement+0x2c>
 678:	00 00       	nop
		_delay_ms(1.250);
		PORTB &= (0<<PB4);
 67a:	85 b1       	in	r24, 0x05	; 5
 67c:	15 b8       	out	0x05, r1	; 5
 67e:	87 e8       	ldi	r24, 0x87	; 135
 680:	93 e1       	ldi	r25, 0x13	; 19
 682:	01 97       	sbiw	r24, 0x01	; 1
 684:	f1 f7       	brne	.-4      	; 0x682 <wrapHeatingElement+0x36>
 686:	00 c0       	rjmp	.+0      	; 0x688 <wrapHeatingElement+0x3c>
 688:	00 00       	nop
	//Invert the direction of the linear drive motor so that the panel mechanism moves backwards
	PORTE &= (0<<PE3);
	//Wait a moment before beginning backwards movement so that it doesn't jerk the whole mechanism
	_delay_ms(500);
	
	for (int i = 0; i < ((int)(full_rot * (18 / lead))); i++) //Stretch muscle 18 mm starting from the home position before wrapping heating element
 68a:	2f 5f       	subi	r18, 0xFF	; 255
 68c:	3f 4f       	sbci	r19, 0xFF	; 255
 68e:	2c 39       	cpi	r18, 0x9C	; 156
 690:	9e e0       	ldi	r25, 0x0E	; 14
 692:	39 07       	cpc	r19, r25
 694:	4c f3       	brlt	.-46     	; 0x668 <wrapHeatingElement+0x1c>
	}
	
	//Begin heating element wrapping
	while (1) {
		//Indicator
		PORTB |= (1<<PB0);
 696:	85 b1       	in	r24, 0x05	; 5
 698:	81 60       	ori	r24, 0x01	; 1
 69a:	85 b9       	out	0x05, r24	; 5
 69c:	2f ef       	ldi	r18, 0xFF	; 255
 69e:	85 ea       	ldi	r24, 0xA5	; 165
 6a0:	9e e0       	ldi	r25, 0x0E	; 14
 6a2:	21 50       	subi	r18, 0x01	; 1
 6a4:	80 40       	sbci	r24, 0x00	; 0
 6a6:	90 40       	sbci	r25, 0x00	; 0
 6a8:	e1 f7       	brne	.-8      	; 0x6a2 <wrapHeatingElement+0x56>
 6aa:	00 c0       	rjmp	.+0      	; 0x6ac <wrapHeatingElement+0x60>
 6ac:	00 00       	nop
		
		_delay_ms(300); //Switch de-bouncing
		waitContinue();
 6ae:	ee dd       	rcall	.-1060   	; 0x28c <waitContinue>
		
		//Indicator
		PORTB &= (0<<PB0);
 6b0:	85 b1       	in	r24, 0x05	; 5
 6b2:	15 b8       	out	0x05, r1	; 5
		
		//Reverse the direction of one of the panels
		//PORTG |= (1<<PG5);
		//PORTJ |= (1<<PJ1);
		PORTG &= (0<<PG5);
 6b4:	84 b3       	in	r24, 0x14	; 20
 6b6:	14 ba       	out	0x14, r1	; 20
		//PORTJ &= (0<<PJ1);
		
		//Begin Panel Motor movement
		analogWriteV2(128);
 6b8:	80 e8       	ldi	r24, 0x80	; 128
 6ba:	90 e0       	ldi	r25, 0x00	; 0
 6bc:	b2 dd       	rcall	.-1180   	; 0x222 <analogWriteV2>
 6be:	2f ef       	ldi	r18, 0xFF	; 255
 6c0:	85 ea       	ldi	r24, 0xA5	; 165
 6c2:	9e e0       	ldi	r25, 0x0E	; 14
 6c4:	21 50       	subi	r18, 0x01	; 1
 6c6:	80 40       	sbci	r24, 0x00	; 0
 6c8:	90 40       	sbci	r25, 0x00	; 0
 6ca:	e1 f7       	brne	.-8      	; 0x6c4 <wrapHeatingElement+0x78>
 6cc:	00 c0       	rjmp	.+0      	; 0x6ce <wrapHeatingElement+0x82>
		
		_delay_ms(300); //Switch de-bouncing
		waitContinue();
 6ce:	00 00       	nop
		
		//Finish and stop all movement
		analogWriteV2(0);
 6d0:	dd dd       	rcall	.-1094   	; 0x28c <waitContinue>
 6d2:	80 e0       	ldi	r24, 0x00	; 0
 6d4:	90 e0       	ldi	r25, 0x00	; 0
 6d6:	a5 dd       	rcall	.-1206   	; 0x222 <analogWriteV2>
 6d8:	de cf       	rjmp	.-68     	; 0x696 <wrapHeatingElement+0x4a>

000006da <main>:
}
*/

int main(void)
{
	machineInit();
 6da:	0c de       	rcall	.-1000   	; 0x2f4 <machineInit>
	home();
 6dc:	b0 de       	rcall	.-672    	; 0x43e <home>
	
	wait();
 6de:	ea dd       	rcall	.-1068   	; 0x2b4 <wait>
 6e0:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
	if (flag == 3) {
 6e4:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 6e8:	03 97       	sbiw	r24, 0x03	; 3
		wrapHeatingElement();
 6ea:	09 f4       	brne	.+2      	; 0x6ee <main+0x14>
	}
	
	stretch();
 6ec:	af df       	rcall	.-162    	; 0x64c <wrapHeatingElement>
 6ee:	c8 de       	rcall	.-624    	; 0x480 <stretch>
	twist();
 6f0:	17 df       	rcall	.-466    	; 0x520 <twist>
 6f2:	38 df       	rcall	.-400    	; 0x564 <move>
	move();
 6f4:	83 df       	rcall	.-250    	; 0x5fc <stop>
 6f6:	80 e0       	ldi	r24, 0x00	; 0
	stop();
 6f8:	90 e0       	ldi	r25, 0x00	; 0
 6fa:	08 95       	ret

000006fc <_exit>:
	//wrapHeatingElement();
	
	//displayData();
 6fc:	f8 94       	cli

000006fe <__stop_program>:
 6fe:	ff cf       	rjmp	.-2      	; 0x6fe <__stop_program>
